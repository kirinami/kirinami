name: Deploy

on:
  push:
    branches:
      - main
      - develop
  workflow_dispatch:

defaults:
  run:
    shell: bash

jobs:
  build:
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Set up container
        run: |
          yarn global add dotenv yaml -E

      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Prepare project
        env:
          NODE_PATH: /home/runner/.config/yarn/global/node_modules
        shell: node {0}
        run: |
          const os = require('os');
          const fs = require('fs');
          const url = require('url');
          const dotenv = require('dotenv');
          const yaml = require('yaml');
          
          /* *** */
          
          const secrets = ${{ toJSON(secrets) }};
          
          const vars = {
            repository: '${{ github.repository }}',
            branch: '${{ github.ref_name }}',
            get name() {
              return `${this.repository.replace(/\/+/, '-')}-${this.branch}`.toLowerCase();
            }
          };
          
          Object.entries(vars).forEach(([key, value]) => {
            fs.appendFileSync(process.env.GITHUB_ENV, `VARS_${key.toUpperCase()}=${value}${os.EOL}`, 'utf-8');
          });
          
          /* *** */
          
          const compose = yaml.parse(fs.readFileSync('docker-compose.yml', 'utf-8'));
          
          Object.entries(compose.services).forEach(([key, service]) => {
            if (service.build) {
              service.build = undefined;
              service.image = `${vars.name}_${key}`;
            }
          
            if (service.ports) {
              service.ports = undefined;
            }
          
            if (service.expose) {
              let env = dotenv.parse(secrets[`ENV_${key.toUpperCase()}_${vars.branch.toUpperCase()}`] || secrets[`ENV_${vars.branch.toUpperCase()}`] || secrets['ENV'] || '');
          
              let host = null;
          
              fs.writeFileSync(
                '.env',
                Object.entries(env)
                  .map(([name, value]) => {
                    if (name === 'BASE_URL') {
                      const parsedUrl = url.parse(value);
          
                      parsedUrl.host = `${['main', 'master'].includes(vars.branch) ? '' : `${vars.branch}.`}${parsedUrl.host}`;
                      parsedUrl.pathname = '';
          
                      host = parsedUrl.host;
          
                      value = parsedUrl.format();                      
                    }
                    return `${name}=${value}`;
                  })
                  .join('\n')
                  .concat('\n'),
                'utf-8'
              );
          
              if (host) {
                service.labels = [
                  ...service.labels || [],
                  'traefik.enable=true',
                  `traefik.http.routers.${vars.name}_${key}.rule=Host(\`${host}\`)`,
                  `traefik.http.routers.${vars.name}_${key}.entrypoints=http`
                ];
          
                service.networks = [
                  ...service.networks || [],
                  'traefik'
                ];
              }
            }
          });
          
          compose.networks = {
            ...compose.networks || {},
            traefik: {
              name: 'traefik',
              external: true
            }
          };
          
          fs.writeFileSync('docker-compose.yml', yaml.stringify(compose, { lineWidth: 120 }), 'utf-8');

      - name: Build docker image
        env:
          DOCKER_BUILDKIT: 1
        run: |
          docker compose -p ${{ env.VARS_NAME }} build
          docker image ls

      - name: Prepare artifacts
        run: |
          mkdir .artifacts
          cp -r public .env docker-compose.yml .artifacts

      - name: Archive artifacts
        uses: actions/upload-artifact@v3
        with:
          path: .artifacts
          retention-days: 1

  deploy:
    needs: [build]
    runs-on: ubuntu-latest
    environment:
      name: production
      url: 'test'
    steps:
      - name: Set up container
        run: |
          mkdir ~/.ssh
          ssh-keyscan -H ${{ secrets.SSH_HOST }} > ~/.ssh/known_hosts
          cat > ~/.ssh/id_rsa <<- 'END'
          ${{ secrets.SSH_PRIVATE_KEY }}
          END
          chmod 400 ~/.ssh/id_rsa

      - name: Download artifacts
        uses: actions/download-artifact@v3

      - name: Test
        run: |
          pwd
          ls -la .
          ls -la ~

#      - name: Upload to server
#        run: |
#          rsync \
#            -arzvh \
#            --progress \
#            --rsync-path="mkdir -p projects/${{ needs.vars.outputs.repo }} && rsync" \
#            artifact/ ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:projects/${{ needs.vars.outputs.repo }}/
#
#      - name: Run on server
#        run: |
#          ssh ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} <<- END
#            pushd projects/${{ needs.vars.outputs.repo }}
#              if [[ -e .docker/${{ needs.vars.outputs.name }}.tar.gz ]]; then docker load < .docker/${{ needs.vars.outputs.name }}.tar.gz; fi
#              docker compose -p ${{ needs.vars.outputs.name }} up -d --remove-orphans
#              docker ps
#            popd
#          END
